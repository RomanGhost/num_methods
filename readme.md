Самарский национальный исследовательский университет

имени академика С.П. Королева

Естественнонаучный институт

Механико-математический факультет

Кафедра информатики и вычислительной математики

> Отчет по лабораторной работе №1 «Вычисление машинного эпсилон. Решение
> систем линейных алгебраических уравнений с треугольными матрицами» по
> дисциплине «Методы вычислений»
>
> Выполнил:
>
> студент группы 4345-020303D
>
> Р.Е. Ильдияров
>
> Проверил:
>
> доцент В.П. Сироченко

Самара-2024

**1. ВЫЧИСЛЕНИЕ МАШИННОГО ЭПСИЛОН**

**1.1 Постановка задачи**

Реализовать алгоритм вычисления машинного эпсилон

**1.2 Краткое описание численного метода**

Машинное эпсилон представляет собой наименьшее положительное число ε,
такое что $1 + varepsilon neq 1$ в представлении с плавающей точкой.
Для его вычисления используется метод последовательного уменьшения
значения до достижения точности меньше, чем машинное эпсилон.

Асимптотическая сложность $O(1)$

Количество действий для вычисления элипсоида: 212

**1.3 Листинг программы**

Среда разработки: RustRover 2023.3 EAP, Build #RR-233.14015.152, built
on February 16, 2024.

Язык программирования: Rust (rustc 1.75.0 (82e1608df 2023-12-21)

+-----------------------------------------------------------------------+
| mod elips;                                                            |
|                                                                       |
| fn main() -> std::io::Result<()> {                                 |
|                                                                       |
| let elips_res_32 = elips::elipsoid32(1.);                             |
|                                                                       |
| let elips_res_64 = elips::elipsoid64(1.);                             |
|                                                                       |
| println!("Accuracy at 32 bit: {}", elips_res_32);                   |
|                                                                       |
| println!("Accuracy at 64 bit: {}", elips_res_64);                   |
|                                                                       |
| Ok(())                                                                |
|                                                                       |
| }                                                                     |
+=======================================================================+
+-----------------------------------------------------------------------+

Листинг 1 - src/main.rs

  -----------------------------------------------------------------------
  pub fn elipsoid64(eps:f64) ->f64{
  let mut new_eps:f64 = eps;
  let mut new_eps1:f64 = 0.0;
  
  loop{
  new_eps /= 2.0;
  new_eps1 = new_eps + 1.0;
  if new_eps1 <= 1.0{
  break;
  }
  }
  new_eps
  }
  
  pub fn elipsoid32(eps:f32) ->f32{
  let mut new_eps:f32 = eps;
  let mut new_eps1:f32 = 0.0;
  
  loop{
  new_eps /= 2.0;
  new_eps1 = new_eps + 1.0;
  if new_eps1 <= 1.0
  {
  break;
  }
  }
  new_eps
  }
  -----------------------------------------------------------------------

  -----------------------------------------------------------------------

Листинг 2 - src/elips.rs

**1.4 Результаты расчетов**

Таблица 1- Расчет элипсоида для одинарной точности

  -----------------------------------------------------------------------
  Входные данные                      Выходные данные
  ----------------------------------- -----------------------------------
  1.0                                 0.000000059604645

  -----------------------------------------------------------------------

Таблица 2 - Расчет элипсоида для двойной точности

  ------------------------------------------------------------------------
  Входные данные                      Выходные данные
  ----------------------------------- ------------------------------------
  1.0                                 0.00000000000000011102230246251565

  ------------------------------------------------------------------------

**2. Решение систем линейных алгебраических уравнений с нижней
треугольной матрицей**

**2.1 Постановка задачи**

Пусть дана система линейных алгебраических уравнений вида:

$$binom{a_{11}x_{1} = b_{1}}{begin{array}{r}
a_{21}x_{1} +  a_{22}x_{2} = b_{2} 
a_{31}x_{1} +  a_{32}x_{2} + a_{33}x_{3} = b_{3} 
ldots 
a_{n1}x_{1} +  a_{n2}x_{2} + ldots + a_{nn}x_{n} = b_{n} 
end{array}}$$

Нужно найти решение системы методом подстановки.

**2.2 Краткое описание численного метода**

Метод обратной подстановки применяется в численном анализе для решения
систем линейных уравнений с треугольными матрицами. Этот метод часто
используется в задачах, где матрицы обладают специальными структурами,
такими как нижняя треугольность, так как он обычно эффективнее общих
методов решения систем.

Используя свойства нижней треугольной матрицы, метод обратной
подстановки решает систему уравнений, начиная с последнего уравнения и
последовательно находя неизвестные от последней к первой.

Этапы алгоритма:

1)  Начнем с последнего уравнения;

2)  Решим уравнение для первой неизвестной:

$$x_{1} = frac{b_{1}}{a_{11}};$$

3)  Подставим найденное значение $x_{1}$​ в предпоследнее уравнение и
    найдем следующую неизвестную:

$$x_{i} = frac{b_{i} - sum_{j = i}^{i - 1}{a_{ij}x_{j}} }{a_{ii}}, i = overline{2, n}$$

4)  Продолжим этот процесс до тех пор, пока не найдем все неизвестные
    $x_{i}$.

> Асимптотическая сложность: $O(n^{2})$

**2.3 Листинг программы**

Среда разработки: RustRover 2023.3 EAP, Build #RR-233.14015.152, built
on February 16, 2024.

Язык программирования: Rust (rustc 1.75.0 (82e1608df 2023-12-21)

  -----------------------------------------------------------------------
  pub fn lower_matrix(a: Vec<Vec<f32>>, b: Vec<f32>) ->Vec<f32>
  {
  let N:usize = b.len();
  
  let mut x=vec![0.0; N];
  x[0] = b[0]/a[0][0];
  let mut summ:f32;
  
  for i in (1..N){
  summ = 0.0;
  for j in (0..i){
  summ += x[j] * a[i][j];
  }
  x[i] = (b[i]-summ)/a[i][i];
  }
  
  return x;
  }
  -----------------------------------------------------------------------

  -----------------------------------------------------------------------

Листинг 3 - src/matrix_count.rs

  -----------------------------------------------------------------------
  use std::io::prelude::*;
  use std::io::BufReader;
  use std::fs::File;
  
  mod matrix_count;
  
  fn read_matrix_file(filename: &str) ->(i32, Vec<Vec<f32>>,
  Vec<f32>){
  let file = File::open(filename).expect("File error");
  let mut reader = BufReader::new(file);
  let mut line = String::new();
  
  // get matrix size
  reader.read_line(&mut line).expect("Line error");
  let n = line.trim().parse::<i32>().unwrap();
  line.clear();
  
  //get matrix from file line
  let mut a:Vec<Vec<f32>> = Vec::new();
  for i in (0..n) {
  reader.read_line(&mut line).expect("Error when parse matrix");
  let k:Vec<f32> = line.split(" ").map(|c|
  c.trim().parse::<f32>().expect("Is not of num")).collect();
  a.push(k);
  line.clear();
  }
  
  // get answer vector
  reader.read_line(&mut line).expect("Error when parse "b"");
  let b:Vec<f32> = line.split(" ").map(|c|
  c.trim().parse::<f32>().expect("Is not of num")).collect();
  line.clear();
  
  (n, a, b)
  }
  
  fn main() -> std::io::Result<()> {
  //примеры решения матричных уравнений
  //Нижнетреугольная матрица
  //1
  let (_, a, b) = read_matrix_file("cache/matrix/down/1.txt");
  let res = matrix_count::lower_matrix(a, b);
  println!("Решение нижнетреугольной матрицы 1:");
  println!("{:?}", res);
  
  //2
  let (_, a, b) = read_matrix_file("cache/matrix/down/2.txt");
  let res = matrix_count::lower_matrix(a, b);
  println!("Решение нижнетреугольной матрицы 2:");
  println!("{:?}", res);
  
  
  Ok(())
  }
  -----------------------------------------------------------------------

  -----------------------------------------------------------------------

Листинг 4 - src/main.rs

**2.4 Результаты расчетов**

Таблица 3 - результаты тестирования решения нижней треугольной матрицы

  ---------------------------------------------------------------------------------------
  Входные данные          Результат                       Ожидаемы результат
  ----------------------- ------------------------------- -------------------------------
  3                      [1.0, 2.0, 3.0]               [1.0, 2.0, 3.0]
  1 0 0                                                  
  2 3 0                                                  
  4 5 6                                                  
  1 8 32                                                  

  5                      [2.2875,4.9700003,42.485413,   [2.2875,4.9700003,42.485413,
  8 0 0 0 0              -24.892885,-15.242246]         -24.892885,-15.242246]
  4 5 0 0 0                                              
  1 9 1.2 0 0                                            
  7.8 9 12.32 23.5 0                                     
  4 7.9 1.1 0.6 5                                        
  18.3 34 98 1.01 4                                       
  ---------------------------------------------------------------------------------------

**3. Решение систем линейных алгебраических уравнений с верхней
треугольной матрицей**

**3.1 Постановка задачи**

Пусть дана система линейных алгебраических уравнений вида:

$$binom{a_{11}x_{1} +  a_{12}x_{2} + a_{23}x_{3} + ldots + a_{1n}x_{n} = b_{1}}{begin{array}{r}
a_{22}x_{2} + a_{23}x_{3} + ldots + a_{2n}x_{n} = b_{2} 
ldots 
a_{nn}x_{n} = b_{n} 
end{array}}$$

Нужно найти решение системы методом подстановки.

**3.2 Краткое описание численного метода**

Метод обратной подстановки применяется в численном анализе для решения
систем линейных уравнений с треугольными матрицами. Этот метод часто
используется в задачах, где матрицы обладают специальными структурами,
такими как нижняя треугольность, так как он обычно эффективнее общих
методов решения систем.

Используя свойства нижней треугольной матрицы, метод обратной
подстановки решает систему уравнений, начиная с последнего уравнения и
последовательно находя неизвестные от последней к первой.

Этапы алгоритма:

1)  Начнем с последнего уравнения;

2)  Решим уравнение для первой неизвестной:

$$x_{n} = frac{b_{n}}{a_{nn}};$$

3)  Подставим найденное значение $x_{1}$​ в предпоследнее уравнение и
    найдем следующую неизвестную:

$$x_{i} = frac{b_{i} - sum_{j = i + 1}^{n}{a_{ij}x_{j}} }{a_{ii}}, i = overline{n - 1, 1}$$

4)  Продолжим этот процесс до тех пор, пока не найдем все неизвестные
    $x_{i}$.

> Асимптотическая сложность: $O(n^{2})$

**3.3 Листинг программы**

Среда разработки: RustRover 2023.3 EAP, Build #RR-233.14015.152, built
on February 16, 2024.

Язык программирования: Rust (rustc 1.75.0 (82e1608df 2023-12-21)

  -----------------------------------------------------------------------
  pub fn upper_matrix(a: Vec<Vec<f32>>, b: Vec<f32>) ->Vec<f32>
  {
  let N:usize = b.len();
  
  let mut x=vec![0.0; N];
  x[N-1] = b[N-1]/a[N-1][N-1];
  let mut summ:f32;
  
  for i in (0..N-1).rev(){
  summ = 0.0;
  for j in (i+1..N){
  summ += x[j] * a[i][j];
  }
  x[i] = (b[i]-summ)/a[i][i];
  }
  
  return x;
  }
  -----------------------------------------------------------------------

  -----------------------------------------------------------------------

Листинг 5 - src/matrix_count.rs

  -----------------------------------------------------------------------
  use std::io::prelude::*;
  use std::io::BufReader;
  use std::fs::File;
  
  mod matrix_count;
  
  fn read_matrix_file(filename: &str) ->(i32, Vec<Vec<f32>>,
  Vec<f32>){
  let file = File::open(filename).expect("File error");
  let mut reader = BufReader::new(file);
  let mut line = String::new();
  
  // get matrix size
  reader.read_line(&mut line).expect("Line error");
  let n = line.trim().parse::<i32>().unwrap();
  line.clear();
  
  //get matrix from file line
  let mut a:Vec<Vec<f32>> = Vec::new();
  for i in (0..n) {
  reader.read_line(&mut line).expect("Error when parse matrix");
  let k:Vec<f32> = line.split(" ").map(|c|
  c.trim().parse::<f32>().expect("Is not of num")).collect();
  a.push(k);
  line.clear();
  }
  
  // get answer vector
  reader.read_line(&mut line).expect("Error when parse "b"");
  let b:Vec<f32> = line.split(" ").map(|c|
  c.trim().parse::<f32>().expect("Is not of num")).collect();
  line.clear();
  
  (n, a, b)
  }
  
  fn main() -> std::io::Result<()> {
  //верхне треугольная матрица
  let (_, a, b) = read_matrix_file("cache/matrix/upper/1.txt");
  let res = matrix_count::upper_matrix(a, b);
  println!("Решение треугольной матрицы 1:");
  println!("{:?}", res);
  
  Ok(())
  }
  -----------------------------------------------------------------------

  -----------------------------------------------------------------------

Листинг 6 - src/main.rs

**3.4 Результаты расчетов**

Таблица 4 - результаты тестирования решения нижней треугольной матрицы

  -----------------------------------------------------------------------
  Входные данные          Результат               Ожидаемы результат
  ----------------------- ----------------------- -----------------------
  3                       [1.0, 2.0, 3.0]         [1.0, 2.0, 3.0]
  1 0 0                                          
  2 3 0                                          
  4 5 6                                          
  1 8 32                                          

  -----------------------------------------------------------------------
